提示： 实现真正的线性化读取可能需要在服务器层做额外的协调，比如确保在返回查询结果前，当前节点已经处理了所有先前的写入命令。你可以先实现简单版本，后续再做精细调控。

启动服务器集群 (run-local-cluster.sh)
- 脚本依次启动了三个服务器实例(server-1-config.toml、server-2-config.toml、server-3-config.toml)
- 调用 Database::new() 连接 PostgreSQL，并执行建表操作（CREATE TABLE IF NOT EXISTS）
- 通过 OmniPaxos 协议建立内部通信和复制机制，确保集群内数据的一致性。

启动客户端 (run-local-client.sh)
- (client-1-config.toml 和 client-2-config.toml)，定义了服务器地址、请求速率、请求类型等参数。
- 首先与服务器建立 TCP 连接，通过注册消息（ClientRegister）识别并等待服务器发出的启动信号。
- 发送 SQL 请求，写入（INSERT ... ON CONFLICT DO UPDATE）和查询（SELECT）操作。


3/7
添加了select时，consistency level的区分，local是直接查询，leader是判断后如果不是leader则转发给leader。实现在server.rs的update_database_and_respond。
但是脚本运行出现较多重复消息语句，有bug

3/12
由于client的leader级别select请求会被leader处理，然后结果发送给对应client。所以对于leader级别的select，leader处理后应该发送给对应的server，转发回复给client

3/14
Linearizable读取 添加等待逻辑。：
当收到一个一致性级别为 Linearizable 的 SELECT 请求时，
检查当前节点的日志应用进度（例如 current_decided_idx 与 self.omnipaxos.get_decided_idx()）。
如果当前节点尚未应用所有已决命令，则等待一段时间（可以轮询或使用条件变量等机制）。
等待到本地状态完全同步后，再执行 SELECT 查询，确保读取结果反映所有先前的写入。

3/15
在 GCP 上创建虚拟机并部署项目
创建 GCP 计算实例（VM）
配置 SSH 访问
上传你的 Omnipaxos-kv 项目
在 GCP 上运行你的容器





